/* $Id: Cloud.java 2015-01-16 12:44:08Z qhobosheanesb $
 * Copyright (C) 2015 Sehlabaka Qhobosheane <qhobosheanesb@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

import java.io.*;
import java.nio.*;
import java.util.*;
import java.lang.NullPointerException;

public class Cloud{
	private Set<InstanceOwner> hosts;
	private Set<InstanceOwner> customers;	
	private int numberOfHosts, numberOfCustomers;
	public final static Cloud INSTANCE = new Cloud();
	private String ioError;
	private String statsFilename;
	private ArrayList<String> stats;	

	private Cloud(){
		hosts = new HashSet<InstanceOwner>();
		customers = new HashSet<InstanceOwner>();
		stats = new ArrayList<>();
	}

	private void linkClientsAndInstances(){
		//@Refactor .. move logic from parseInputAndPopulateObjects() method so as to improve its running time.
	}

	private void calculateHostClustering()throws NullPointerException{
		/* Calculate customer with largest fraction of their total fleet of instances on single host, and output value for the 
		   fraction
		*/
		HashMap<Integer,Integer> hostClusteringMap = new HashMap<Integer,Integer>();
		int count;
		for(InstanceOwner client : customers){			
			if(((Customer)client).getNumberOfInstances() > 0){
				for(Instance inst : ((Customer)client).getInstances()){
					if(hostClusteringMap.containsKey(inst.getHostID())){
						count = hostClusteringMap.get(inst.getHostID());
						hostClusteringMap.put(inst.getHostID(),count+1);
					}
					else{
						hostClusteringMap.put(inst.getHostID(),1);
						//hostclusteringmap.put(client.getID(),inst.getHostID());
					}
				}

				// determine dominant host and ratio				
				((Customer)client).setClusteringFactor(0); 
				for(Map.Entry<Integer,Integer> entry : hostClusteringMap.entrySet()){
					if((Integer)entry.getValue() > ((Customer)client).getClusteringFactor()){
						((Customer)client).setClusteringFactor((Integer)entry.getValue()); 
						((Customer)client).setDominantHost((Integer)entry.getKey());
					}
				}				
			}	
			hostClusteringMap.clear();		
		}
		
		int maxFactor = 0, busyhost = 0, payingClient = 0,totalFleet = 0;
		for(InstanceOwner client : customers){    			
			if(((Customer)client).getClusteringFactor() > maxFactor){
				maxFactor = ((Customer)client).getClusteringFactor();
				busyhost = ((Customer)client).getDominantHost();
				payingClient = ((Customer)client).getID();
				totalFleet = ((Customer)client).getNumberOfInstances();
			}
		}
		String sHostClustering = "HostClustering:"+payingClient+","+maxFactor+"/"+totalFleet;
		stats.add(sHostClustering);
	}

	private void determineAvailableHosts()throws NullPointerException {
		// Calculate a list of all hosts which have atleast one empty slot				
		if(hosts.size() > 0){
			StringBuilder availHosts = new StringBuilder(hosts.size()); // assume all hosts are available
			availHosts.append("\nAvailableHosts:");
			for(InstanceOwner h : hosts){
				if(((Host)h).getAvailableSlots() > 0){
					availHosts.append(((Host)h).getID());
					availHosts.append(",");
				}
			}
			availHosts.deleteCharAt(availHosts.lastIndexOf(","));
			availHosts.trimToSize();		
			stats.add(availHosts.toString());
		}		
	}

	private void calculateDatacenterClustering()throws NullPointerException{
		/* Calculate customer with the largest fraction of their total fleet of instances in a single datacenter and output the
		   fraction
		*/
		
		/* .. DO TO:
		 *	. Loop over both hosts and customers sets counting instances of each customer running on hosts with same datacenterID.
		 *	. Store the count into field datacenterClusteringFactor
		 *	. Once finished iterating on both sets, iterate over customers set to determine customer with highest clustering
		 *	  factor per datacenter and log that to file.	
		 */	
	
		int count;
		HashMap<Integer,Integer> hostClusteringMap = new HashMap<Integer,Integer>();
		HashMap<Integer,Integer> datacenterClusteringMap = new HashMap<Integer,Integer>();		

		for(InstanceOwner client : customers){				
			if(((Customer)client).getNumberOfInstances() > 0){
				for(Instance inst : ((Customer)client).getInstances()){
					if(hostClusteringMap.containsKey(inst.getHostID())){
						count = hostClusteringMap.get(inst.getHostID());
						hostClusteringMap.put(inst.getHostID(),count+1);
					}
					else{
						hostClusteringMap.put(inst.getHostID(),1);
						//hostclusteringmap.put(client.getID(),inst.getHostID());
					}
				}
			
				// now add the hostID counts into datacenter counts				
				for(InstanceOwner theHost : hosts){					
					if(hostClusteringMap.containsKey(((Host)theHost).getID())){
						count = hostClusteringMap.get(((Host)theHost).getID());
						if(datacenterClusteringMap.containsKey(((Host)theHost).getDatacenterID())){
							count += datacenterClusteringMap.get(((Host)theHost).getDatacenterID());
							datacenterClusteringMap.put(((Host)theHost).getDatacenterID(),count);
						}
						else{
							datacenterClusteringMap.put(((Host)theHost).getDatacenterID(),count);
						}
					}
				}

				// determine dominant datacenter and ratio				
				((Customer)client).setDatacenterClusteringFactor(0); 
				for(Map.Entry<Integer,Integer> entry : datacenterClusteringMap.entrySet()){
					if((Integer)entry.getValue() > ((Customer)client).getDatacenterClusteringFactor()){
						((Customer)client).setDatacenterClusteringFactor((Integer)entry.getValue()); 
						((Customer)client).setDominantDatacenter((Integer)entry.getKey());
					}
				}				
			}	
			hostClusteringMap.clear();
			datacenterClusteringMap.clear();					
		}

		int maxFactor = 0, busycenter = 0, payingClient = 0,totalFleet = 0;
		for(InstanceOwner client : customers){    			
			if(((Customer)client).getDatacenterClusteringFactor() > maxFactor){
				maxFactor = ((Customer)client).getDatacenterClusteringFactor();
				busycenter = ((Customer)client).getDominantDatacenter();
				payingClient = ((Customer)client).getID();
				totalFleet = ((Customer)client).getNumberOfInstances();
			}
		}
		String sDatacenterClustering = "\nDatacenterClustering:"+payingClient+","+maxFactor+"/"+totalFleet;
		stats.add(sDatacenterClustering);		
	}
	
	/*
	 * For more stats to calculate, just edit this method.
	 */
	private void calculateSummaryStats(){	
		try{	
			calculateHostClustering();
			calculateDatacenterClustering();
			determineAvailableHosts();	
		}
		catch(NullPointerException npex){
			System.err.println(npex);
		}		
	}

	private boolean writeOutputStats(){
		boolean success = false;
		try{
			
			FileWriter writer = new FileWriter(statsFilename,false);
			if(stats.size() > 0){
				for(String s : stats){
					writer.write(s);
				}
			}
			stats.clear();
			writer.close();
			success = true;
		}
		catch(IOException e){
			System.err.println(e + " while generating summary statistics file.");
		}
		return success;
	}

	private boolean parseInputAndPopulateObjects(String hostsFilename,String instancesFilename) throws IOException{
		// first attempt to read hostStates file
		File hostsFile, instancesFile;
		FileReader fr;
		BufferedReader br1 = null, br2 = null; 		
		boolean success = true;
		String sCurrentLine;
		int hostid = 0,customerid = 0,instanceid = 0,numSlots = 0,datacenterid = 0, line=0, hostCount=0, instanceCount=0;
		try { 			
 			hostsFile = new File(hostsFilename);
			fr = new FileReader(hostsFile);
			br1 = new BufferedReader(fr);
 
			// Load Hosts -- O(n)
			while ((sCurrentLine = br1.readLine()) != null) {
				++line;
				// Process host states input
				String[] tokens = sCurrentLine.split(",");
				if(tokens.length < 3){
					ioError = "Hosts States - Malformed Input Error at line " + Integer.toString(line) + 
						     " - Only "+Integer.toString(tokens.length) + 
						     " tokens detected. Expected format = <hostID>,<numberOfSlots>,<datacentreID>.";
					success = false;
					break;
				}
				else{
					// first retrieve the hostID, then numberOfSlots and lastly datacenterID
					hostid = Integer.parseInt(tokens[0]);
					numSlots = Integer.parseInt(tokens[1]);
					datacenterid = Integer.parseInt(tokens[2]);
				
					// create a host object and add it to the cloud
					InstanceOwner ahost = new Host(hostid,numSlots,datacenterid);
					if(addHost(ahost)){
						++hostCount;
					}
					else{
						System.out.println("Attempting to load host which is already on the cloud! Host("+
								   tokens[0]+",+"+tokens[1]+","+tokens[2]+") line "+Integer.toString(line));
					}
				}
			}
			if(success){ // continue loading only if no error has been encounted
				System.out.println("\nLoaded "+Integer.toString(hostCount) + " hosts into cloud.");	

				// Now Load Instances into their respective hosts -- O(nxm)?! needs to be refactored
				br2 = new BufferedReader(new FileReader(new File(instancesFilename)));
 				line = 0;

				while ((sCurrentLine = br2.readLine()) != null) {
					++line;
					// Process Instance states input
					String[] tokens2 = sCurrentLine.split(",");
					if(tokens2.length < 3){
						ioError = "Instance States - Malformed Input Error - Only "+
							     Integer.toString(tokens2.length) + 
							     " tokens detected. Expected format = <instanceID>,<customerID>,<hostID>.";
						success = false;
						break;
					}
					else{
						// first retrieve the instanceID, then customerID and lastly hostID
						instanceid = Integer.parseInt(tokens2[0]);			
						customerid = Integer.parseInt(tokens2[1]);						
						hostid = Integer.parseInt(tokens2[2]);
					
						// create an instance object and add it to its host. also create a customer object and
						// add it to clients set(if not present already).
						Instance anInstance = new Instance(instanceid,customerid,hostid);
						InstanceOwner client = new Customer(customerid);
						
						customers.add(client);		
						
						for(InstanceOwner cust : customers){
							if(cust.equals(client))
								cust.addInstance(anInstance);
						}

						//  loop through all registered hosts to find the one this instance belongs to
						for(InstanceOwner a : hosts){
							if(((Host)a).getID() == hostid){
								if(((Host)a).addInstance(anInstance)){
									++instanceCount;
								}
								else{
									System.out.println("Attempting to load an instance on a "+
											   "host twice! Instance("+tokens2[0]+",+"+tokens2[1]+
											   ","+tokens2[2]+") line "+Integer.toString(line));
								}
								break; // an instance can only be associated with 2 host.
							}
						}
					}
				}			 
				if(success)System.out.println("\nLoaded "+Integer.toString(instanceCount) + " Instances into cloud.");
			}	
		}
		catch(FileNotFoundException fnfex){
			System.out.println(fnfex.getMessage() + " Please make certain the provided filename is correct, and that the"+
							        " file exists in the specified location.");			
		}
		catch(IOException e) {
			throw (new IOException(e + " when trying to load hosts and instances onto cloud."));
		}
		finally{
			try{
				if(br1 != null)br1.close();
				if(br2 != null)br2.close();				
			}
			catch (IOException ex){
				//ex.printStackTrace();
				System.err.println(ex);
			}
		}	
		return success;
	}

	/*
	 *  Display the entire cloud infrastructure to stdout.
	 */ 
	private void display(){
		System.out.println("###########################################################################");
		System.out.println("****************** View of all Hosts and their Instances ******************");
		System.out.println("***************************************************************************\n");
		System.out.println("Host[hostId,numberOfSlots,datacenterId]");
		System.out.println("\tInstance[instanceId,customerId,hostId]");
		for(InstanceOwner a : hosts){
			if(((Host)a).equals(null)){				
				System.out.println("["+Integer.toString(((Host)a).getID())+
						   ","+Integer.toString(((Host)a).getNumberOfSlots())+","+
						   Integer.toString(((Host)a).getDatacenterID())+"]");
				if(((Host)a).getNumberOfInstances() > 0){
					for(Instance i : ((Host)a).getInstances()){	
						if(i != null){			
							System.out.println("\t["+Integer.toString(i.getID())+
									   ","+Integer.toString(i.getCustomerID())+","+
									   Integer.toString(i.getHostID())+"]\n");
						}
					}					
				}
				System.out.println("---------------------------------\n");
			}					    
		}
		System.out.println("###########################################################################");
		System.out.println("*************** View of all Customers and their Instances *****************");
		System.out.println("***************************************************************************\n");
		System.out.println("Customer[customerId]");
		System.out.println("\tInstance[instanceId,customerId,hostId]");
		for(InstanceOwner client : customers){
			System.out.println("["+Integer.toString(((Customer)client).getID())+"]");
			if(((Customer)client).getInstances().size() > 0){
				for(Instance i : ((Customer)client).getInstances()){								
					System.out.println("\t["+Integer.toString(i.getID())+
							       ","+Integer.toString(i.getCustomerID())+","+
							       Integer.toString(i.getHostID())+"]\n");
					
				}					
			}			
			System.out.println("---------------------------------\n");
		}
		System.out.println("###########################################################################\n\n");
	}		
	
	/*
	 *  Cloud interpreter that interacts with user and generates output.
	 */    		
	public void run(){
    		InputStreamReader inputStreamReader = null;
		BufferedReader stdin = null;
		Scanner userInput = null;
    		try {
			/*inputStreamReader = new InputStreamReader(System.in);
    			stdin = new BufferedReader(inputStreamReader);*/
    			boolean quit = false, errorOccured = false;
    			String result = null, host_fname = null, instance_fname = null,statistics_fname = null;
			char yes;
			userInput = new Scanner(System.in);

			System.out.println("***************************************************************************");
			System.out.println("*********************** Amazon Cloud Infrastructure ***********************");	
			System.out.println("***************************************************************************\n");
      			while(!quit){        			
				System.out.println("Please enter a qualified file name for host states. e.g[HostState.txt] ");
				host_fname = userInput.nextLine();
				if(host_fname == null || ("".equals(host_fname)))host_fname = "HostState.txt";				
				System.out.println("Now enter a qualified file name for instance states. e.g[InstanceState.txt] ");
				instance_fname = userInput.nextLine();
				if(instance_fname == null || ("".equals(instance_fname)))instance_fname = "InstanceState.txt";
				System.out.println("And finally enter a preferred name for the output statistics file. e.g[Statistics.txt] ");
				statsFilename = userInput.nextLine();
				if(statsFilename == null || ("".equals(statsFilename)))statsFilename = "Statistics.txt";
				
				if(parseInputAndPopulateObjects(host_fname,instance_fname)){	
					linkClientsAndInstances();				
        				calculateSummaryStats();							
					if(!writeOutputStats())
						System.out.println("Error generating summary statistics. " + ioError);
				}
				else{
					System.out.println("Error processing input. " + ioError);
					errorOccured = true;
				}								
				
				System.out.println("\nDo you wish to continue? [y/Y] \n([d/D]Displays loaded hosts and customers. "+
						   "Anything else quits.)");
				yes = userInput.nextLine().charAt(0);
				if((yes == 'd') || (yes == 'D')){
					display();
					yes = 'y';	
				}								
				quit = ((yes != 'y') && (yes != 'Y'));
				
				// if continue, ask whether to retain previous cloud state or not
				if(!quit){
					System.out.println("Do you want to retain current cloud state? [y/Y] (Anything else clears.)");
					yes = userInput.nextLine().charAt(0);
					if(((yes != 'y') && (yes != 'Y'))){
						hosts.clear();
						customers.clear();
						numberOfHosts = 0;
						numberOfCustomers = 0;
						stats.clear();
					}					
				}			
      			}
    		}
		catch(StringIndexOutOfBoundsException siobe){
			System.out.println("bye");			
		}
    		catch (Exception ex) {
      			System.out.println(ex);
    		}
    		finally {      			
      			System.out.println("\n\nCloud received the Shutdown SIGNAL...\nShutting down Cloud...");
    		}  		
	}

	/*private void shutdown(Reader aStdin){
    		try {
      			aStdin.close();
   		 }
   		 catch (IOException ex){
     			System.err.println(ex);
   		 }
  	}*/
	
	public boolean addHost(InstanceOwner host){
		if(hosts.add(host)){
			++numberOfHosts;
			return true;
		}
		return false;
	}

	public boolean addCustomer(InstanceOwner client){
		if(customers.add(client)){
			++numberOfCustomers;
			return true;
		}
		return false;
	}

	public Set<InstanceOwner> getHosts(){
		return hosts;
	}

	public Set<InstanceOwner> getCustomers(){
		return customers;
	}	
	
	public static void main(String args[]){				
		Cloud amazon = Cloud.INSTANCE;
		amazon.run();
		System.out.println("au revoir :)");
	}
}
